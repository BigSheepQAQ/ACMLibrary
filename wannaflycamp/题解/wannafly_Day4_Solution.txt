G 枚举哪一档，然后算一下钱够不够，不够接着氪钱
L 找规律发现一定是1, 2, 3, ..., x, n/(x-1), n/(x-2), .... x是sqrt(n)附近
J 模拟，用一个map记录一下两两之间聊了几句和最近时间，用一个set当堆，然后每次修改的时候就p_old[x],x,p_new[x]三个点的状态会变
C 状压dp+简单计算。注意有模仿怪所以不要无脑吃宝石即可。
F max C(n,a) C(m,b) p^a (1-p)^(n-a) (2p)^b (1-2p)^(m-b) 取对数求导之后解个二次方程或者二分即可。
H 一个前缀/后缀代价为本身长度-border长度，hash+kmp即可。
I KM，然后求出每个点删掉之后的最大权匹配，这个只要把顶标和边权改成0，然后跑一边KM中的增光即可，然后类似一个半平面交的东西，由于范围很小可以枚举每个人跑不等式。
K c个人中，相对排名k，这个人期望是k(n+1)/(c+1)。倒着dp，看选这个人的期望与选后面人的期望，需要一个树状数组统计排名。
A 首先固定一号点标0，那么与一号点相邻的标2^i，对于一个标号x，如果已经确定了x-2^a,x-2^b，那么这个点可以被唯一确定。接下来就相当与这些位可以随便调换，每个位关于这2^n个数字是个01序列，然后排个序即可。
D 对偶费用流，努力卡了很久之比LP快了一点点，只好卡内存了。
E 任意不满足的状态对答案的贡献为1，所以只需要求出每个不够的状态的概率最后加上1。我们认为我们总共需要4*sum c件衣服，每次抽如果没到达c，那么贡献为4，否则贡献为1。dp[i][j][k]表示前i件衣服，抽了j件，总贡献为k的概率和。
B 黑科技wiki Montgomery modular multiplication/ 现在在32位机上跑不过暴力，所以用long double试除就能过