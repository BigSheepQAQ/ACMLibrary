birthday:
思路：考虑费用流时把每个part拆成n个点，选择第i个点的代表为放置i块蛋糕和(i - 1)块蛋糕的时间差，这个时间差是递增的，因此在费用流的过程中必定会从小到大选择
具体建图：左边n个点代表n个蛋糕，右边m * n个点代表m个part,每个part拆成n个点。源点向每个左边的点连一条流量1费用0的边，每个右边的点向汇点连一条流量1费用0的编。每个蛋糕向可以放的两个part的所有点连边，连向第i个点的费用为i^2 - (i - 1)^2，流量为1。这样求最小费用流既为答案。


board:
把格子N染色，第i行第j列格子的颜色为(i + j) % N。那么每次操作时，必定是N种不同的颜色都有一格被操作到，因此最后任何颜色格子的和必定是相等的。因此只需要记录每种颜色格子的和，并算出缺失格子的颜色C，用其余颜色的和减去颜色C的和即可

Circle：
因为(i,i+1)=1且(1,n)=1，所以把1...n依次放进一个环，就可以啦。答案为n。

Growth：
把奖励的x拿出来从小到大排序，得到x1,x2,...,xn。
把奖励的y拿出来从小到大排序，得到y1,y2,...,yn。
用v[i][j]表示a值到达xi，b值达到yi时接下来每天可以得到的奖励。
v[i][j] = v[i - 1][j] + v[i][j - 1] - v[i - 1][j - 1] + t[i][j]
其中t[i][j]为满足x=i，y=j的奖励的总和。
用f[i][j]表示a值达到xi，b值达到yj时已经拿到的奖励的最大值。
f[i][j] + (x[i + 1] - x[i] - 1) * t[i][j] + t[i + 1][j] -> f[i + 1][j]
f[i][j] + (y[j + 1] - y[j] - 1) * t[i][j] + t[i][j + 1] -> f[i][j + 1]
最后统计一下答案就可以了。

kingdom:
f[i]代表i个点时的答案，g[i][j]代表若干颗树加起来，size和为i，每棵树size<=j时，这些树的代价和最大是多少
从1到n枚举i，在i固定时枚举心腹的影响力大小更新f[i]，然后用类似背包的思路更新g[i][1]~g[i][i]
复杂度O(N^2)


Matrix：
w个格子的重心的坐标为（∑xi*wi / ∑wi, ∑yi*wi / ∑wi)。
那么其实我们只要维护∑xi*wi，∑yi*wi，∑wi就可以了。
假设我们现在有一个顶点为(x, y)的三角形，我们想要推到顶点为(x, y+1)的三角形，观察两者之间的差异，会发现在推过去的过程中，其实就是删去了一个斜条，又加入了一个斜条。
同理，从(x, y)到(x+1, y)其实只是删去了两个斜条，加上了底上的横条，而这些关键的值都是可以通过前缀和的方法维护。

Mountain：
考虑山中最高的一座，最优操作一定是从第一座山的左下角开始不停地往上爬，然后从最高的山不停地往下爬爬到最后一座山的右下角。
所以答案为最高山的高度*2。

清明梦:
首先每条路径从LCA处分开可以拆成两条链
假设链A->B执行了第i次染色操作，假设A是B的祖先，那么我们在B点加入一个"插入i"的事件，在A的父亲点加入一个"删除i"的事件
然后dfs整颗树求解，每个点维护一个线段树。处理一个点时先合并所有儿子的线段树，然后再处理这个点上的事件，得到线段树之后询问第K大值既可得到答案。
复杂度分析：
Node* merge(Node* a, Node* b) {
    if (a == NULL) return b;
    if (b == NULL) return a;
    a->sum += b->sum;
    a->child[0] = merge(a->child[0], b->child[0]);
    a->child[1] = merge(a->child[1], b->child[1]);
    return a;
}
考虑以上的线段树合并，每次合并会减少一个区间。而在事件点插入、删除的时候会产生至多log个区间，因此复杂度为O(NLogN)


最短路：本题十分直接。我们不断地把度数为1的点删掉，把度数为2的点收缩，最后会得到一个图，和原图的点数与边数之差相同，且新图中每个点的度数都至少是3。这就是说我们会得到一个200个点300条边以内的图。新图可以用Floyd算法预处理所有点对之间最短路。询问时，将询问转化到新图上即可。转化时需要注意细节。


排序：设m是a和b的差的lowbit。我们先假设m是1，即a和b的奇偶性不同。这时通过适当的构造，我们可以用常数步交换任意两个奇偶互异的数字的位置。交换奇偶相同的数只要借一个和它们奇偶不同的数即可。如此我们便可交换任意两个数，即此时没有无解。下面考虑m大于1。我们称一个数字x的低位为(x&(m-1))，高位为x减去它的低位。我们发现数组的低位是无法利用交换魔法的，只能用到加法和异或。也就是说，我们必须用加法和异或排好数组的低位。排好低位后，我们按照低位将所有数字分为若干组，每组内（和之前m为1的情况类似）是没有无解的。现在问题只剩如何用加法和异或排好低位。可以发现，a[0],…,a[m-1]的低位和a[m],…,a[2m-1]的低位必须完全一致且均为0到m-1的一个排列，否则它们无法同时通过加法和异或排好。同理a[2m],…,a[3m-1]的低位也必须一致。所以，我们只要用加法和异或排好a[0],…,a[m-1]即可。这其实是本题的n=m且没有交换魔法的版本（因为现在超过m-1的加法和异或是没用的）。在这个版本下，从升序排列只能生成(m/2)*(2**(m/2))种不同的排列。这些排列可以用递归法构造：m=2时用一次加法即可（后面会解释为什么用加法不用异或）。m更大时，我们发现连续使用加1和异或1可以达到奇数都加2，偶数都不变的效果。这个操作实际相当于只考虑奇数且不考虑个位情况下的加1操作。这就可以提取所有奇数做递归，将所有奇数排列成任意的m/2时的可能排列。同理，先异或1再加1起到的是偶数加2奇数不变的效果。我们相似地递归偶数部分。注意到，递归一侧时，异或操作是会影响另一侧的。奇数和偶数两侧的异或操作的异或和必须相同（因为整体考虑，异或操作其实是同时作用在奇数和偶数上的！），除了个位和最高位。（除了个位是因为我们根本不考虑个位，个位有值的异或操作只用在异或1的时候了。除了最高位是因为最高位异或可以用奇数+2操作模拟出来。）这样可以得到的排列数最多为(m/2)*(2**(m/2))，同时满足条件的排列都可以用递归法构造出来。


土龙弟弟：下面会有一些定义。出此题是期望比赛的时候大家凭感觉得到结论，不证明。
首先题目问的是在torus上扣若干个洞，所得曲面上的闭环的同伦等价类。（定义：torus：就是我们定义的地图，形似甜甜圈。闭环：就是说土龙弟弟一天走的路径。因为会回来所以叫闭环。同伦等价类：就是一个土龙弟弟的路线可能会变换。凡是可能属于同一个土龙弟弟的两条路线就是相互同伦的。题目问的就是最少能分成多少组使得组内相互同伦。）我们把扣掉的洞用线连起来，使得线之间不相交且按照线将曲面分割成若干简单的部分。（简单的部分：就是这一部分是你在纸上随便画个不自交的闭环得到的东西。简单是因为这一个区域中所有的闭环都同伦，因为可以缩小到很小再移动到一起。）分割区域这一步需要小构造一下。大体思路就是每一行都画一条横的线，这线实际会被洞分割成多条线。然后有些区域是个环（即从左边走到最右边再向右回到最左边），即并非简单区域。这些区域再画一条竖线。
这样分割后，一个闭环就可以用依次穿过的线的编号组成的字符串来表示（除了记录哪条线，方向也有用。并且由于是环，字符串也是循环的。）然后消去相邻相反括号（即连续的正穿和反穿同一条线的部分。因为每个区域都是简单的，所以连续正穿和反穿中间的部分可以不断收缩直到不穿过这条线，所以消去后所得的曲线和之前是同伦的。）最后为了判断循环串相等要用最小表示法。证明：我们要证的是同伦当且仅当消去相邻相反括号后的序列循环相等。 假设a经过消括号得到（不能再消的）b，显然a和b是同伦的，因为每一步都同伦。假设a'消括号得到b'。如果b和b'循环相等,a和b同伦。这就证明了一半。反过来，对一个曲线做同伦变换时，只能产生或消除相邻的相反括号。所以如果b和b'不等，他们又都没有相邻相反括号可以消去，它们就不可能通过产生和消除相邻相反括号相互转换，即b和b'不同伦，即a和a'不可能同伦。
最后注意没有洞是特殊情况。题面里除去了这种情况。其实torus上扣若干洞后的基本群总是free group，但是没扣洞时的基本群是Z^2（平面整数格点加法群）。